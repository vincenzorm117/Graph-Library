

import java.util.ArrayList;
import java.util.Hashtable;

/**
 * 
 * @author Vincenzo Marconi
 * @version 1.0
 * 
 *
 */
public class Vertex {

	private static int number = 0;
	
	/**
	 * Graph class uses it to run specific methods. 
	 * The value in accordance to all other vertices of the same Graph must be unique.
	 */
	public int name;
	
	/**
	 * Contains a set of edges that are coming into the vertex.
	 */
	public ArrayList<Edge> in;
	
	/**
	 * Contains a set of edges that are coming out of the vertex. 
	 */
	public ArrayList<Edge> out;
	
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Constructs a vertex out of a name. A vertex has to be given a name. The ArrayLists in and out are initialized and empty.
	 * @param name an integer representative of a name which must be unique.
	 */
	public Vertex(){
		this.in = new ArrayList<Edge>();
		this.out = new ArrayList<Edge>();
		this.name = number++;
	}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

	/**
	 * Determines whether the passed object is a Vertex.
	 * @see Edge#anEdge(Object)
	 * @param o The object to check to see if it is a Vertex
	 * @return False if null, name less than 0, and if in and out are null; True otherwise. 
	 */
	public static boolean aVertex(Object o){
	
		//Case: Object exist and is a Vertex?
		if(o instanceof Vertex){
			Vertex v = (Vertex)o;
			
			if(v.name >= 0 && v.in != null && v.out != null)
				return true;
		}
		
		// If no conditions describing an vertex are met return false
		return false;
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 *  Returns the number of incoming and outgoing edges connected to the Vertex.
	 */
	public int degree(){
		return in.size() + out.size();
	}
	
	/**
	 * Returns the number of incoming edges.
	 */
	public int inDegree(){
		return in.size();
	}
	
	/**
	 * Returns the number of outgoing edges.
	 */
	public int outDegree(){
		return out.size();
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Returns a String containing the name of the vertex.
	 * @return String
	 */
	public String toString(){
		return ""+this.name ;
	}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Checks whether the passed vertex is adjacent to given vertex.
	 * @param v
	 * @return boolean
	 */
	public boolean isAdjacentTo(Vertex v){
		if(this.outDegree() == 0) return false;
		
		for(Edge e : this.out)
			if(e.opposite(v) == v)
				return true;
		
		return false;
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Returns an ArrayList containing all of the edges going out of vertex.
	 * @return ArrayList
	 */
	public ArrayList<Edge> incidentOutEdges(){
	
		ArrayList<Edge> edges = new ArrayList<Edge>();
		
		for(Edge e : this.out)	
			edges.add(e);
		
		return edges;
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

	/**
	 * Returns all of the edges incoming and outgoing that return a Label value of Unexplored from the passed Hashtable.
	 * @see Label
	 * @param edgeLabels
	 * @return ArrayList
	 */
	public ArrayList<Edge> allUnexploredNeighbors(Hashtable<Edge,Label> edgeLabels){
		
		if(edgeLabels == null) throw new NullPointerException("Hashtable argument is null");
		
		if(this.degree() == 0) return null;
		
		ArrayList<Edge> edges = new ArrayList<Edge>();
			
		for(Edge e : this.out)	
			if(edgeLabels.get(e) == Label.UNEXPLORED)
				edges.add(e);
		
		for(Edge e : this.in)	
			if(edgeLabels.get(e) == Label.UNEXPLORED)
				edges.add(e);
		
		return edges;
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Returns all of the edges incident on the Vertex.
	 * @return ArrayList
	 */
	public ArrayList<Edge> incidentEdges(){
		
		ArrayList<Edge> edges = new ArrayList<Edge>();
			
		for(Edge e : this.out)	
			edges.add(e);
		
		for(Edge e :  this.in)
			edges.add(e);
	
		return edges;
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Returns all of the outgoing edges that return a value of Unexplored from the passed Hashtable.
	 * @param edgeLabels Contains a Label (value) for an Edge (key)
	 * @return ArrayList
	 */
	public ArrayList<Edge> unexploredOutNeighbors(Hashtable<Edge,Label> edgeLabels){
		
		if(edgeLabels == null) throw new NullPointerException("Hashtable argument is null");
		
		if(this.outDegree() == 0) return null;
		
		ArrayList<Edge> edges = new ArrayList<Edge>();
			
		for(Edge e : this.out)	
			if(edgeLabels.get(e) == Label.UNEXPLORED)
				edges.add(e);
		
		
		return edges;
	}
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

	/**
	 * Returns all of the incoming edges that return a value of Unexplored from the passed Hashtable.
	 * @param edgeLabels Contains a Label (value) for an Edge (key)
	 * @return ArrayList
	 */
	public ArrayList<Edge> unexploredInNeighbors(Hashtable<Edge,Label> edgeLabels){
	
		if(edgeLabels == null) throw new NullPointerException("Hashtable argument is null");
		
		if(this.inDegree() == 0) return null;
		
		ArrayList<Edge> edges = new ArrayList<Edge>();
		
		for(Edge e : this.in)	
			if(edgeLabels.get(e) == Label.UNEXPLORED)
				edges.add(e);
		
		
		return edges;
	}

	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
	

}
